name: Docker Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

# Cancel in-progress runs for PRs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  # Use Docker BuildKit for faster builds
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      docker-changed: ${{ steps.changes.outputs.docker }}
      code-changed: ${{ steps.changes.outputs.code }}
      docker-first-enabled: ${{ steps.config.outputs.enabled }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check Docker-first configuration
        id: config
        run: |
          if [[ -f ".claude/config.json" ]]; then
            if command -v jq >/dev/null 2>&1; then
              enabled=$(jq -r '.features.docker_first_development // false' .claude/config.json)
              echo "enabled=$enabled" >> $GITHUB_OUTPUT
            else
              echo "enabled=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "enabled=false" >> $GITHUB_OUTPUT
          fi

      - name: Detect file changes
        id: changes
        run: |
          # Check if Docker files changed
          if git diff --name-only HEAD~1 HEAD | grep -E "(Dockerfile|docker-compose|\.dockerignore)" > /dev/null; then
            echo "docker=true" >> $GITHUB_OUTPUT
          else
            echo "docker=false" >> $GITHUB_OUTPUT
          fi
          
          # Check if source code changed
          if git diff --name-only HEAD~1 HEAD | grep -E "\.(js|ts|jsx|tsx|py|go|java|rs|php)$" > /dev/null; then
            echo "code=true" >> $GITHUB_OUTPUT
          else
            echo "code=false" >> $GITHUB_OUTPUT
          fi

  docker-tests:
    name: Docker Tests
    runs-on: ubuntu-latest
    needs: detect-changes
    # Run if Docker-first is enabled OR if Docker files changed
    if: needs.detect-changes.outputs.docker-first-enabled == 'true' || needs.detect-changes.outputs.docker-changed == 'true'
    
    strategy:
      matrix:
        # Test against multiple environments
        test-env: [development, test]
        
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log Docker info
        run: |
          docker version
          docker-compose version

      - name: Create .env file for testing
        run: |
          cat > .env << 'EOF'
          NODE_ENV=test
          DATABASE_URL=postgresql://testuser:testpass@test-db:5432/testdb
          REDIS_URL=redis://redis:6379
          CI=true
          EOF

      - name: Build development image
        run: |
          echo "Building development image..."
          if [[ -f "Dockerfile.dev" ]]; then
            docker build -f Dockerfile.dev -t app:dev .
          else
            echo "Warning: Dockerfile.dev not found, using main Dockerfile"
            docker build -t app:dev .
          fi

      - name: Build production image
        run: |
          echo "Building production image..."
          docker build -t app:prod .

      - name: Run Docker Compose tests
        run: |
          echo "Running tests with docker-compose..."
          
          # Use test configuration if available
          if [[ -f "docker-compose.test.yml" ]]; then
            echo "Using docker-compose.test.yml"
            docker-compose -f docker-compose.yml -f docker-compose.test.yml run --rm test
          elif [[ -f "docker-compose.dev.yml" ]]; then
            echo "Using docker-compose.dev.yml for tests"
            docker-compose -f docker-compose.yml -f docker-compose.dev.yml run --rm app npm test || \
            docker-compose -f docker-compose.yml -f docker-compose.dev.yml run --rm app pytest || \
            docker-compose -f docker-compose.yml -f docker-compose.dev.yml run --rm app go test ./...
          else
            echo "Running tests in production container"
            docker run --rm app:prod npm test || \
            docker run --rm app:prod pytest || \
            docker run --rm app:prod go test ./...
          fi

      - name: Run linting in Docker
        run: |
          echo "Running linting in Docker..."
          
          # Node.js linting
          if [[ -f "package.json" ]]; then
            docker run --rm app:dev npm run lint || echo "Linting not configured or failed"
          fi
          
          # Python linting
          if [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]]; then
            docker run --rm app:dev ruff check . || \
            docker run --rm app:dev flake8 . || \
            docker run --rm app:dev pylint . || \
            echo "Python linting not configured or failed"
          fi
          
          # Go linting
          if [[ -f "go.mod" ]]; then
            docker run --rm app:dev golangci-lint run || echo "Go linting not configured or failed"
          fi

      - name: Security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'app:prod'
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true

      - name: Test container startup
        run: |
          echo "Testing container startup..."
          
          # Start container in background
          if [[ -f "docker-compose.yml" ]]; then
            docker-compose up -d
            
            # Wait for startup
            sleep 10
            
            # Check if container is healthy
            docker-compose ps
            
            # Stop containers
            docker-compose down
          else
            echo "No docker-compose.yml found, testing direct container run"
            # Test if container starts without immediate crash
            timeout 10 docker run --rm app:prod || echo "Container startup test completed"
          fi

      - name: Cleanup
        if: always()
        run: |
          docker-compose down -v --remove-orphans || true
          docker system prune -f || true

  docker-build-matrix:
    name: Multi-platform Build
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.docker-first-enabled == 'true'
    
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build for ${{ matrix.platform }}
        run: |
          docker buildx build \
            --platform ${{ matrix.platform }} \
            --tag app:${{ matrix.platform }} \
            --load \
            .

  validate-docker-first-compliance:
    name: Validate Docker-First Compliance
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.docker-first-enabled == 'true'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check required Docker files
        run: |
          echo "Checking for required Docker files..."
          
          missing_files=()
          [[ ! -f "Dockerfile" ]] && missing_files+=("Dockerfile")
          [[ ! -f "docker-compose.yml" ]] && missing_files+=("docker-compose.yml")
          [[ ! -f ".dockerignore" ]] && missing_files+=(".dockerignore")
          
          if [[ ${#missing_files[@]} -gt 0 ]]; then
            echo "❌ Missing required Docker files: ${missing_files[*]}"
            echo ""
            echo "Docker-first development is enabled but required files are missing."
            echo "Create them with: ./.claude/scripts/docker-dev-setup.sh"
            exit 1
          fi
          
          echo "✅ All required Docker files present"

      - name: Validate Docker Compose configuration
        run: |
          echo "Validating docker-compose.yml..."
          docker-compose config -q
          echo "✅ Docker Compose configuration is valid"

      - name: Check for local development bypasses
        run: |
          echo "Checking for potential Docker-first bypasses..."
          
          # Look for scripts that might run local commands
          if find . -name "*.sh" -o -name "*.py" -o -name "*.js" | xargs grep -l "npm install\|pip install\|python.*\.py" 2>/dev/null; then
            echo "⚠️  Found potential Docker-first bypasses in scripts"
            echo "Review these files to ensure they use Docker commands"
          else
            echo "✅ No obvious Docker-first bypasses found"
          fi

  report-status:
    name: Report Test Status
    runs-on: ubuntu-latest
    needs: [detect-changes, docker-tests, validate-docker-first-compliance]
    if: always()
    
    steps:
      - name: Report Success
        if: needs.docker-tests.result == 'success' && needs.validate-docker-first-compliance.result == 'success'
        run: |
          echo "✅ All Docker tests and validations passed!"
          echo "Safe to merge - Docker environment is working correctly"

      - name: Report Failure
        if: needs.docker-tests.result == 'failure' || needs.validate-docker-first-compliance.result == 'failure'
        run: |
          echo "❌ Docker tests or validations failed!"
          echo "DO NOT MERGE until Docker issues are resolved"
          exit 1

      - name: Report Skipped
        if: needs.detect-changes.outputs.docker-first-enabled != 'true'
        run: |
          echo "ℹ️ Docker tests skipped - Docker-first development is disabled"