{"ast":null,"code":"/**\n * Audio conversion utilities for converting WebM to WAV format\n */\n\n/**\n * Convert WebM blob to WAV blob\n * @param {Blob} webmBlob - The WebM audio blob\n * @returns {Promise<Blob>} WAV audio blob\n */\nexport const convertWebMToWav = async webmBlob => {\n  return new Promise((resolve, reject) => {\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const fileReader = new FileReader();\n    fileReader.onloadend = async () => {\n      try {\n        const arrayBuffer = fileReader.result;\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n\n        // Convert AudioBuffer to WAV\n        const wavArrayBuffer = audioBufferToWav(audioBuffer);\n        const wavBlob = new Blob([wavArrayBuffer], {\n          type: 'audio/wav'\n        });\n        audioContext.close();\n        resolve(wavBlob);\n      } catch (error) {\n        console.error('Error converting WebM to WAV:', error);\n        audioContext.close();\n        reject(error);\n      }\n    };\n    fileReader.onerror = () => {\n      reject(new Error('Failed to read audio file'));\n    };\n    fileReader.readAsArrayBuffer(webmBlob);\n  });\n};\n\n/**\n * Convert AudioBuffer to WAV ArrayBuffer\n * @param {AudioBuffer} audioBuffer - The audio buffer to convert\n * @returns {ArrayBuffer} WAV format array buffer\n */\nfunction audioBufferToWav(audioBuffer) {\n  const numOfChan = audioBuffer.numberOfChannels;\n  const sampleRate = audioBuffer.sampleRate;\n  const length = audioBuffer.length * numOfChan * 2 + 44;\n  const buffer = new ArrayBuffer(length);\n  const view = new DataView(buffer);\n  const channels = [];\n  let offset = 0;\n  let pos = 0;\n\n  // Helper functions to write data\n  const setUint16 = data => {\n    view.setUint16(pos, data, true);\n    pos += 2;\n  };\n  const setUint32 = data => {\n    view.setUint32(pos, data, true);\n    pos += 4;\n  };\n\n  // Write WAV header\n  // \"RIFF\" identifier\n  setUint32(0x46464952);\n  // File length minus RIFF identifier length and file description length\n  setUint32(length - 8);\n  // \"WAVE\" identifier\n  setUint32(0x45564157);\n  // \"fmt \" chunk identifier\n  setUint32(0x20746d66);\n  // Format chunk length\n  setUint32(16);\n  // Sample format (PCM)\n  setUint16(1);\n  // Channel count\n  setUint16(numOfChan);\n  // Sample rate\n  setUint32(sampleRate);\n  // Byte rate (sample rate * block align)\n  setUint32(sampleRate * numOfChan * 2);\n  // Block align (channel count * bytes per sample)\n  setUint16(numOfChan * 2);\n  // Bits per sample\n  setUint16(16);\n  // \"data\" chunk identifier\n  setUint32(0x61746164);\n  // Data chunk length\n  setUint32(length - pos - 4);\n\n  // Extract channel data\n  for (let i = 0; i < audioBuffer.numberOfChannels; i++) {\n    channels.push(audioBuffer.getChannelData(i));\n  }\n\n  // Write interleaved PCM samples\n  while (pos < length) {\n    for (let i = 0; i < numOfChan; i++) {\n      // Interleave channels\n      let sample = channels[i][offset];\n\n      // Clamp sample to [-1, 1] range\n      sample = Math.max(-1, Math.min(1, sample));\n\n      // Convert to 16-bit PCM\n      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;\n\n      // Write 16-bit sample\n      view.setInt16(pos, sample, true);\n      pos += 2;\n    }\n    offset++;\n  }\n  return buffer;\n}\n\n/**\n * Alternative simple conversion using MediaRecorder with WAV mime type\n * @param {MediaStream} stream - The media stream to record\n * @returns {Promise<Blob>} WAV audio blob\n */\nexport const recordAsWav = stream => {\n  return new Promise((resolve, reject) => {\n    const chunks = [];\n\n    // Try to use WAV mime type if supported\n    const mimeTypes = ['audio/wav', 'audio/wave', 'audio/webm', 'audio/ogg'];\n    let selectedMimeType = 'audio/webm'; // Default fallback\n    for (const mimeType of mimeTypes) {\n      if (MediaRecorder.isTypeSupported(mimeType)) {\n        selectedMimeType = mimeType;\n        break;\n      }\n    }\n    const mediaRecorder = new MediaRecorder(stream, {\n      mimeType: selectedMimeType\n    });\n    mediaRecorder.ondataavailable = event => {\n      if (event.data.size > 0) {\n        chunks.push(event.data);\n      }\n    };\n    mediaRecorder.onstop = async () => {\n      const blob = new Blob(chunks, {\n        type: selectedMimeType\n      });\n\n      // If already WAV, return as is\n      if (selectedMimeType.includes('wav')) {\n        resolve(blob);\n      } else {\n        // Convert to WAV\n        try {\n          const wavBlob = await convertWebMToWav(blob);\n          resolve(wavBlob);\n        } catch (error) {\n          // Fallback: return original blob\n          console.warn('WAV conversion failed, using original format:', error);\n          resolve(blob);\n        }\n      }\n    };\n    mediaRecorder.onerror = error => {\n      reject(error);\n    };\n    return mediaRecorder;\n  });\n};\n\n/**\n * Get supported audio MIME type for recording\n * @returns {string} The best supported MIME type\n */\nexport const getSupportedMimeType = () => {\n  const types = ['audio/wav', 'audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/mp4'];\n  for (const type of types) {\n    if (MediaRecorder.isTypeSupported(type)) {\n      return type;\n    }\n  }\n  return 'audio/webm'; // Default fallback\n};\nexport default {\n  convertWebMToWav,\n  recordAsWav,\n  getSupportedMimeType\n};","map":{"version":3,"names":["convertWebMToWav","webmBlob","Promise","resolve","reject","audioContext","window","AudioContext","webkitAudioContext","fileReader","FileReader","onloadend","arrayBuffer","result","audioBuffer","decodeAudioData","wavArrayBuffer","audioBufferToWav","wavBlob","Blob","type","close","error","console","onerror","Error","readAsArrayBuffer","numOfChan","numberOfChannels","sampleRate","length","buffer","ArrayBuffer","view","DataView","channels","offset","pos","setUint16","data","setUint32","i","push","getChannelData","sample","Math","max","min","setInt16","recordAsWav","stream","chunks","mimeTypes","selectedMimeType","mimeType","MediaRecorder","isTypeSupported","mediaRecorder","ondataavailable","event","size","onstop","blob","includes","warn","getSupportedMimeType","types"],"sources":["/Users/rla/Projects/Speecher/src/react-frontend/src/utils/audioConverter.js"],"sourcesContent":["/**\n * Audio conversion utilities for converting WebM to WAV format\n */\n\n/**\n * Convert WebM blob to WAV blob\n * @param {Blob} webmBlob - The WebM audio blob\n * @returns {Promise<Blob>} WAV audio blob\n */\nexport const convertWebMToWav = async (webmBlob) => {\n  return new Promise((resolve, reject) => {\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const fileReader = new FileReader();\n\n    fileReader.onloadend = async () => {\n      try {\n        const arrayBuffer = fileReader.result;\n        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n        \n        // Convert AudioBuffer to WAV\n        const wavArrayBuffer = audioBufferToWav(audioBuffer);\n        const wavBlob = new Blob([wavArrayBuffer], { type: 'audio/wav' });\n        \n        audioContext.close();\n        resolve(wavBlob);\n      } catch (error) {\n        console.error('Error converting WebM to WAV:', error);\n        audioContext.close();\n        reject(error);\n      }\n    };\n\n    fileReader.onerror = () => {\n      reject(new Error('Failed to read audio file'));\n    };\n\n    fileReader.readAsArrayBuffer(webmBlob);\n  });\n};\n\n/**\n * Convert AudioBuffer to WAV ArrayBuffer\n * @param {AudioBuffer} audioBuffer - The audio buffer to convert\n * @returns {ArrayBuffer} WAV format array buffer\n */\nfunction audioBufferToWav(audioBuffer) {\n  const numOfChan = audioBuffer.numberOfChannels;\n  const sampleRate = audioBuffer.sampleRate;\n  const length = audioBuffer.length * numOfChan * 2 + 44;\n  const buffer = new ArrayBuffer(length);\n  const view = new DataView(buffer);\n  const channels = [];\n  let offset = 0;\n  let pos = 0;\n\n  // Helper functions to write data\n  const setUint16 = (data) => {\n    view.setUint16(pos, data, true);\n    pos += 2;\n  };\n\n  const setUint32 = (data) => {\n    view.setUint32(pos, data, true);\n    pos += 4;\n  };\n\n  // Write WAV header\n  // \"RIFF\" identifier\n  setUint32(0x46464952);\n  // File length minus RIFF identifier length and file description length\n  setUint32(length - 8);\n  // \"WAVE\" identifier\n  setUint32(0x45564157);\n  // \"fmt \" chunk identifier\n  setUint32(0x20746d66);\n  // Format chunk length\n  setUint32(16);\n  // Sample format (PCM)\n  setUint16(1);\n  // Channel count\n  setUint16(numOfChan);\n  // Sample rate\n  setUint32(sampleRate);\n  // Byte rate (sample rate * block align)\n  setUint32(sampleRate * numOfChan * 2);\n  // Block align (channel count * bytes per sample)\n  setUint16(numOfChan * 2);\n  // Bits per sample\n  setUint16(16);\n  // \"data\" chunk identifier\n  setUint32(0x61746164);\n  // Data chunk length\n  setUint32(length - pos - 4);\n\n  // Extract channel data\n  for (let i = 0; i < audioBuffer.numberOfChannels; i++) {\n    channels.push(audioBuffer.getChannelData(i));\n  }\n\n  // Write interleaved PCM samples\n  while (pos < length) {\n    for (let i = 0; i < numOfChan; i++) {\n      // Interleave channels\n      let sample = channels[i][offset];\n      \n      // Clamp sample to [-1, 1] range\n      sample = Math.max(-1, Math.min(1, sample));\n      \n      // Convert to 16-bit PCM\n      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;\n      \n      // Write 16-bit sample\n      view.setInt16(pos, sample, true);\n      pos += 2;\n    }\n    offset++;\n  }\n\n  return buffer;\n}\n\n/**\n * Alternative simple conversion using MediaRecorder with WAV mime type\n * @param {MediaStream} stream - The media stream to record\n * @returns {Promise<Blob>} WAV audio blob\n */\nexport const recordAsWav = (stream) => {\n  return new Promise((resolve, reject) => {\n    const chunks = [];\n    \n    // Try to use WAV mime type if supported\n    const mimeTypes = [\n      'audio/wav',\n      'audio/wave',\n      'audio/webm',\n      'audio/ogg'\n    ];\n    \n    let selectedMimeType = 'audio/webm'; // Default fallback\n    for (const mimeType of mimeTypes) {\n      if (MediaRecorder.isTypeSupported(mimeType)) {\n        selectedMimeType = mimeType;\n        break;\n      }\n    }\n    \n    const mediaRecorder = new MediaRecorder(stream, {\n      mimeType: selectedMimeType\n    });\n    \n    mediaRecorder.ondataavailable = (event) => {\n      if (event.data.size > 0) {\n        chunks.push(event.data);\n      }\n    };\n    \n    mediaRecorder.onstop = async () => {\n      const blob = new Blob(chunks, { type: selectedMimeType });\n      \n      // If already WAV, return as is\n      if (selectedMimeType.includes('wav')) {\n        resolve(blob);\n      } else {\n        // Convert to WAV\n        try {\n          const wavBlob = await convertWebMToWav(blob);\n          resolve(wavBlob);\n        } catch (error) {\n          // Fallback: return original blob\n          console.warn('WAV conversion failed, using original format:', error);\n          resolve(blob);\n        }\n      }\n    };\n    \n    mediaRecorder.onerror = (error) => {\n      reject(error);\n    };\n    \n    return mediaRecorder;\n  });\n};\n\n/**\n * Get supported audio MIME type for recording\n * @returns {string} The best supported MIME type\n */\nexport const getSupportedMimeType = () => {\n  const types = [\n    'audio/wav',\n    'audio/webm;codecs=opus',\n    'audio/webm',\n    'audio/ogg;codecs=opus',\n    'audio/mp4'\n  ];\n  \n  for (const type of types) {\n    if (MediaRecorder.isTypeSupported(type)) {\n      return type;\n    }\n  }\n  \n  return 'audio/webm'; // Default fallback\n};\n\nexport default {\n  convertWebMToWav,\n  recordAsWav,\n  getSupportedMimeType\n};"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,gBAAgB,GAAG,MAAOC,QAAQ,IAAK;EAClD,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAMC,YAAY,GAAG,KAAKC,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,kBAAkB,EAAE,CAAC;IAC7E,MAAMC,UAAU,GAAG,IAAIC,UAAU,CAAC,CAAC;IAEnCD,UAAU,CAACE,SAAS,GAAG,YAAY;MACjC,IAAI;QACF,MAAMC,WAAW,GAAGH,UAAU,CAACI,MAAM;QACrC,MAAMC,WAAW,GAAG,MAAMT,YAAY,CAACU,eAAe,CAACH,WAAW,CAAC;;QAEnE;QACA,MAAMI,cAAc,GAAGC,gBAAgB,CAACH,WAAW,CAAC;QACpD,MAAMI,OAAO,GAAG,IAAIC,IAAI,CAAC,CAACH,cAAc,CAAC,EAAE;UAAEI,IAAI,EAAE;QAAY,CAAC,CAAC;QAEjEf,YAAY,CAACgB,KAAK,CAAC,CAAC;QACpBlB,OAAO,CAACe,OAAO,CAAC;MAClB,CAAC,CAAC,OAAOI,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;QACrDjB,YAAY,CAACgB,KAAK,CAAC,CAAC;QACpBjB,MAAM,CAACkB,KAAK,CAAC;MACf;IACF,CAAC;IAEDb,UAAU,CAACe,OAAO,GAAG,MAAM;MACzBpB,MAAM,CAAC,IAAIqB,KAAK,CAAC,2BAA2B,CAAC,CAAC;IAChD,CAAC;IAEDhB,UAAU,CAACiB,iBAAiB,CAACzB,QAAQ,CAAC;EACxC,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,SAASgB,gBAAgBA,CAACH,WAAW,EAAE;EACrC,MAAMa,SAAS,GAAGb,WAAW,CAACc,gBAAgB;EAC9C,MAAMC,UAAU,GAAGf,WAAW,CAACe,UAAU;EACzC,MAAMC,MAAM,GAAGhB,WAAW,CAACgB,MAAM,GAAGH,SAAS,GAAG,CAAC,GAAG,EAAE;EACtD,MAAMI,MAAM,GAAG,IAAIC,WAAW,CAACF,MAAM,CAAC;EACtC,MAAMG,IAAI,GAAG,IAAIC,QAAQ,CAACH,MAAM,CAAC;EACjC,MAAMI,QAAQ,GAAG,EAAE;EACnB,IAAIC,MAAM,GAAG,CAAC;EACd,IAAIC,GAAG,GAAG,CAAC;;EAEX;EACA,MAAMC,SAAS,GAAIC,IAAI,IAAK;IAC1BN,IAAI,CAACK,SAAS,CAACD,GAAG,EAAEE,IAAI,EAAE,IAAI,CAAC;IAC/BF,GAAG,IAAI,CAAC;EACV,CAAC;EAED,MAAMG,SAAS,GAAID,IAAI,IAAK;IAC1BN,IAAI,CAACO,SAAS,CAACH,GAAG,EAAEE,IAAI,EAAE,IAAI,CAAC;IAC/BF,GAAG,IAAI,CAAC;EACV,CAAC;;EAED;EACA;EACAG,SAAS,CAAC,UAAU,CAAC;EACrB;EACAA,SAAS,CAACV,MAAM,GAAG,CAAC,CAAC;EACrB;EACAU,SAAS,CAAC,UAAU,CAAC;EACrB;EACAA,SAAS,CAAC,UAAU,CAAC;EACrB;EACAA,SAAS,CAAC,EAAE,CAAC;EACb;EACAF,SAAS,CAAC,CAAC,CAAC;EACZ;EACAA,SAAS,CAACX,SAAS,CAAC;EACpB;EACAa,SAAS,CAACX,UAAU,CAAC;EACrB;EACAW,SAAS,CAACX,UAAU,GAAGF,SAAS,GAAG,CAAC,CAAC;EACrC;EACAW,SAAS,CAACX,SAAS,GAAG,CAAC,CAAC;EACxB;EACAW,SAAS,CAAC,EAAE,CAAC;EACb;EACAE,SAAS,CAAC,UAAU,CAAC;EACrB;EACAA,SAAS,CAACV,MAAM,GAAGO,GAAG,GAAG,CAAC,CAAC;;EAE3B;EACA,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG3B,WAAW,CAACc,gBAAgB,EAAEa,CAAC,EAAE,EAAE;IACrDN,QAAQ,CAACO,IAAI,CAAC5B,WAAW,CAAC6B,cAAc,CAACF,CAAC,CAAC,CAAC;EAC9C;;EAEA;EACA,OAAOJ,GAAG,GAAGP,MAAM,EAAE;IACnB,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,SAAS,EAAEc,CAAC,EAAE,EAAE;MAClC;MACA,IAAIG,MAAM,GAAGT,QAAQ,CAACM,CAAC,CAAC,CAACL,MAAM,CAAC;;MAEhC;MACAQ,MAAM,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEH,MAAM,CAAC,CAAC;;MAE1C;MACAA,MAAM,GAAGA,MAAM,GAAG,CAAC,GAAGA,MAAM,GAAG,MAAM,GAAGA,MAAM,GAAG,MAAM;;MAEvD;MACAX,IAAI,CAACe,QAAQ,CAACX,GAAG,EAAEO,MAAM,EAAE,IAAI,CAAC;MAChCP,GAAG,IAAI,CAAC;IACV;IACAD,MAAM,EAAE;EACV;EAEA,OAAOL,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMkB,WAAW,GAAIC,MAAM,IAAK;EACrC,OAAO,IAAIhD,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAM+C,MAAM,GAAG,EAAE;;IAEjB;IACA,MAAMC,SAAS,GAAG,CAChB,WAAW,EACX,YAAY,EACZ,YAAY,EACZ,WAAW,CACZ;IAED,IAAIC,gBAAgB,GAAG,YAAY,CAAC,CAAC;IACrC,KAAK,MAAMC,QAAQ,IAAIF,SAAS,EAAE;MAChC,IAAIG,aAAa,CAACC,eAAe,CAACF,QAAQ,CAAC,EAAE;QAC3CD,gBAAgB,GAAGC,QAAQ;QAC3B;MACF;IACF;IAEA,MAAMG,aAAa,GAAG,IAAIF,aAAa,CAACL,MAAM,EAAE;MAC9CI,QAAQ,EAAED;IACZ,CAAC,CAAC;IAEFI,aAAa,CAACC,eAAe,GAAIC,KAAK,IAAK;MACzC,IAAIA,KAAK,CAACpB,IAAI,CAACqB,IAAI,GAAG,CAAC,EAAE;QACvBT,MAAM,CAACT,IAAI,CAACiB,KAAK,CAACpB,IAAI,CAAC;MACzB;IACF,CAAC;IAEDkB,aAAa,CAACI,MAAM,GAAG,YAAY;MACjC,MAAMC,IAAI,GAAG,IAAI3C,IAAI,CAACgC,MAAM,EAAE;QAAE/B,IAAI,EAAEiC;MAAiB,CAAC,CAAC;;MAEzD;MACA,IAAIA,gBAAgB,CAACU,QAAQ,CAAC,KAAK,CAAC,EAAE;QACpC5D,OAAO,CAAC2D,IAAI,CAAC;MACf,CAAC,MAAM;QACL;QACA,IAAI;UACF,MAAM5C,OAAO,GAAG,MAAMlB,gBAAgB,CAAC8D,IAAI,CAAC;UAC5C3D,OAAO,CAACe,OAAO,CAAC;QAClB,CAAC,CAAC,OAAOI,KAAK,EAAE;UACd;UACAC,OAAO,CAACyC,IAAI,CAAC,+CAA+C,EAAE1C,KAAK,CAAC;UACpEnB,OAAO,CAAC2D,IAAI,CAAC;QACf;MACF;IACF,CAAC;IAEDL,aAAa,CAACjC,OAAO,GAAIF,KAAK,IAAK;MACjClB,MAAM,CAACkB,KAAK,CAAC;IACf,CAAC;IAED,OAAOmC,aAAa;EACtB,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMQ,oBAAoB,GAAGA,CAAA,KAAM;EACxC,MAAMC,KAAK,GAAG,CACZ,WAAW,EACX,wBAAwB,EACxB,YAAY,EACZ,uBAAuB,EACvB,WAAW,CACZ;EAED,KAAK,MAAM9C,IAAI,IAAI8C,KAAK,EAAE;IACxB,IAAIX,aAAa,CAACC,eAAe,CAACpC,IAAI,CAAC,EAAE;MACvC,OAAOA,IAAI;IACb;EACF;EAEA,OAAO,YAAY,CAAC,CAAC;AACvB,CAAC;AAED,eAAe;EACbpB,gBAAgB;EAChBiD,WAAW;EACXgB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}